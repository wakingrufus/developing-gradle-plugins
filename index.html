<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">
    <style>
        .grid-area {
            display: grid;
            grid-auto-flow: column;
        }

        .reveal pre code {
            max-height: none;
        }

        .reveal pre {
            width: 100%;
        }

        .inline-image img {
            margin: 0;
        }

        .inline-image {
            display: inline-flex;
        }
    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section data-timing="20">
            <h1>Gradle Plugins</h1>
            <img alt="necronomicon but with the gradle logo" src="gradlenomicon.jpg" height="466" width="386">
            <aside class="notes">
                Welcome to developing gradle plugins
                Please, do not be scared off by this book. I have read this book so you don't have to.
                I can tell you what you need to know and leave out the unspeakable horrors contained within.
            </aside>
        </section>
        <section data-timing="60">
            <h1>About Me</h1>
            <aside class="notes">
                You can also find me on the Chicago Tech and Kotlin slacks and the CJUG discord
            </aside>
            <h3>John Burns</h3>
            <div class="grid-area">
                <div style="text-align: left">
                    <p>Staff Engineer @ GrubHub</p>
                    <p>CKUG Co-Organizer</p>
                    <p class="inline-image"><img alt="twitter logo" src="Twitter-Logo.png" height="48" width="48"/>
                        <span style="padding-left: .5em">@wakingrufus</span></p>
                    <p class="inline-image"><img alt="fediverse logo" src="fediverse.png" height="48" width="48"/>
                        <span style="padding-left: .5em">@wakingrufus@mastodon.technology</span>
                    </p>
                </div>
            </div>
        </section>
        <section data-timing="60">
            <h1>About GrubHub</h1>
            <aside class="notes">
                What I do: Service Platform Engineering: JVM Stewardship
            </aside>
        </section>
        <section data-timing="90">
            <h1>About You</h1>
            <h4 class="fragment">Gradle Users</h4>
            <h4 class="fragment">Plugin Authors</h4>
            <h4 class="fragment">Terrified of Gradle</h4>
            <aside class="notes">
                how many use gradle in hobby or work projects?
                how many are plugin authors, or even written a custom task
                how many when you hear the word gradle a feeling of dread washes over you
                my goal is to encourage more people to fall into that second category.
                I might not fix the dread though.
            </aside>
        </section>
        <section data-timing="90">
            <h1>The Problem</h1>
            <aside class="notes">
                Every team has just one person who actually understand the buildscripts. if you are lucky, 2.
                usually it starts when something breaks,
                and 1 person figures out how to fix it, and in doing so they learn about how it works.
                then next time something breaks, the person it breaks for gets frustrated b/c they just want their
                code to run dangit! not understanding the arcane workings of a build tool.
                so after trying and failing a few times, they just go to the person who fixed it before, and they
                figure it out
                and this happens again and again,
                until the fixer is spending most of their time just fixing people problems instead of doing their
                real job
                but then before they realize it buildscripts ARE their real job
                and all of a sudden they are on stage talking to a bunch of people about gradle plugins!
            </aside>
        </section>
        <section data-timing="60">
            <h1>The Goal</h1>
            <ul>
                <li class="fragment">Abstract away the complexity</li>
                <li class="fragment">Simplify standard usage</li>
                <li class="fragment">Without preventing customization</li>
            </ul>

            <aside class="notes">
                Everyone should understand WHAT the scripts do, but they shouldn't always need to know HOW.
                Make the normal case turn-key, allow for customization.
                I will show you how to achieve this using gradle plugins.
                but first, lets get some background about our build tool
            </aside>
        </section>
        <section>
            <section data-auto-animate data-timing="90">
                <h1>Maven vs Gradle</h1>
                <div class="grid-area">
                    <div class="fragment">
                        <h3>Maven</h3>
                        <ul>
                            <li>Declarative via XML</li>
                            <li>Extended with Plugins</li>
                        </ul>
                    </div>
                    <div class="fragment">
                        <h3>Gradle</h3>
                        <ul>
                            <li>DSL</li>
                            <li>Extended with Plugins</li>
                        </ul>
                    </div>
                </div>
                <aside class="notes">
                    Maven is declarative. Gradle has a DSL.
                    with either tool, we can use plugins to abstract away complexity and follow DRY principles
                    The gradle DSL lets us break out of DSL and into imperative code: a blessing and a curse
                </aside>
            </section>
            <section data-auto-animate data-timing="30">
                <h1>DSL</h1>
                <aside class="notes">
                    Here, the DSL looks very declarative great right?
                </aside>
                <pre class="groovy"><code data-trim data-noescape>
plugins {
  id "java"
  id "jacoco"
}
repositories {
  mavenCentral()
}
dependencies {
  implementations("commons-io:commons-io:2.7")

  testImplementation("org.junit.jupiter:junit-jupiter-api:5.4.+")
  testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.4.+")
  testImplementation("org.junit.jupiter:junit-jupiter-params:5.4.+")
  testImplementation("org.assertj:assertj-core:3.23.1")
}
test {
  useJUnitPlatform()
}

                </code></pre>
            </section>
            <section data-auto-animate>
                <h1>DSL</h1>
                <aside class="notes">
                    But say we need something a little custom eg the dependencyUpdates plugin.
                    This is not declarative. There is a lot of code here. complexity. regex!
                    Once figured out, everyone else copies this magical incantation,
                    and if you ever want to change it, you have 1000 places you need to change it.
                </aside>
                <pre class="groovy"><code data-trim data-noescape>
def isNonStable = { String version ->
    def stableKeyword = ['RELEASE', 'FINAL', 'GA']
        .any { it -> version.toUpperCase().contains(it) }
    def regex = /^[0-9,.v-]+(-r)?$/
    return !stableKeyword && !(version ==~ regex)
}
def excludeList = ["guice", "guava"]
tasks.named("dependencyUpdates").configure {
    resolutionStrategy {
        componentSelection {
            all {
                if (isNonStable(it.candidate.version)) {
                    reject('Release candidate')
                } else if (excludeList.contains(it.candidate.module)){
                    reject('dependency excluded from upgrades')
                }
            }
        }
    }
}
                </code></pre>
            </section>
            <section data-auto-animate data-timing="120">
                <h1>DSL</h1>
                <aside class="notes">
                    The ideal is a one liner that lets us say "apply my org's standard depupdates plugin"
                    Consider: imperative code, code repeated between projects
                    when sufficiently pluginified, then scripts are declarative
                    Before we talk about how to make a plugin, we first need to understand how gradle works
                </aside>
                <pre class="groovy"><code data-trim data-noescape data-line-numbers="4">
                plugins {
                  id "java"
                  id "jacoco"
                  id "com.myorg.gradle.depupdates"
                }
                </code></pre>
            </section>
        </section>
        <section>
            <section data-timing="120">
                <h1>Gradle lifecycle</h1>
                <aside class="notes">
                    Gradle builds run in 3 phases
                    buildSrc is your incubator. it is a great place to try writing custom tasks and plugins before
                    pulling them out to a separate codebase / artifact
                </aside>
                <div class="grid-area">
                    <div class="fragment">
                        <h4>Initialization</h4>
                        <ul>
                            <li>buildSrc</li>
                            <li>init scripts</li>
                            <li>settings.gradle</li>
                        </ul>
                    </div>
                    <div class="fragment">
                        <h4>Configuration</h4>
                        <ul>
                            <li>Plugins</li>
                            <li>Build scripts</li>
                        </ul>
                    </div>
                    <div class="fragment">
                        <h4>Execution</h4>
                        <ul>
                            <li>Tasks</li>
                        </ul>
                    </div>
                </div>
            </section>
        </section>
        <section>
            <section data-timing="120">
                <h1>Groovy or Kotlin?</h1>
                <aside class="notes">
                    Basic scripts: can be cross language source compatible
                    complex scripts:
                        More online examples are in groovy
                        groovy is more succinct so can be easier to read
                    plugins:
                        easier to write with type safety
                    caveat: When targeting many major versions of gradle, you may want to avoid kotlin to avoid kotlin language
                    incompatibilities
                </aside>
                <p class="fragment">Basic scripts: doesn't matter</p>
                <p class="fragment">Complex scripts: Groovy</p>
                <p class="fragment">Plugins: Kotlin</p>
            </section>
            <section data-timing="30">
                <h1>Groovy DSL</h1>
                <img src="groovy-dsl.png">
            </section>
            <section data-timing="30">
                <h1>Kotlin DSL</h1>
                <img src="kotlin-dsl.png">
            </section>
        </section>
        <section>
            <section data-auto-animate data-timing="30">
                <h1>Building Blocks</h1>
                <h3 class="fragment">Tasks</h3>
                <h3 class="fragment">Extensions</h3>
                <h3 class="fragment">Plugins</h3>
            </section>
        </section>
        <section>
            <section data-auto-animate>
                <h1>Tasks</h1>
                <h3>Workhorse of the Execution phase</h3>
            </section>
            <section data-auto-animate>
                <h1>Tasks</h1>
                <h3>Inputs -> TaskAction -> Outputs</h3>
            </section>
            <section data-auto-animate>
                <h1 data-id="title">Tasks</h1>
                <aside class="notes">
                    The TaskAction is what the task does when it runs.
                    To define inputs and outputs, we use annotated properties
                    unopinionated
                </aside>
                <pre data-id="code" class="kotlin"><code data-trim data-noescape>
                    abstract class MyTask : DefaultTask() {
                        @get:OutputFile
                        abstract val outputFile: Property&lt;File>

                        @get:InputFile
                        abstract val inputFile: Property&lt;File>

                        @TaskAction
                        fun doWork(){
                            outputFile.get().writeText(doThing(inputFile.get()))
                        }
                    }
                </code></pre>
            </section>
            <section data-auto-animate>
                <h1 data-id="title">Tasks</h1>
                <h3 data-id="subtitle">Companion Object</h3>
                <aside class="notes">
                    for tasks that usually are only created once per project,
                    put a companion object in the Task class (kotlin) with a JvmStatic method that takes a project,
                    and registers the task, then applies all the default opinions,
                    just to make the plugin code simpler for the default case.
                    and then you can always just register the task the regular way if you want one with no opinions
                    you could do a similar thing with a static method in groovy/java
                    that kind of spiritually aligns with the "use static methods instead of public constructors" advice
                    from effective Java
                    without sacrificing the idiom of not hard-coding opinions on tasks/extensions
                    set properties and defaults
                </aside>
                <pre data-id="code" class="kotlin fragment"><code data-trim data-noescape data-line-numbers>
                    abstract class MyTask : DefaultTask() {
                        companion object {
                            @JvmStatic
                            fun create(project: Project,
                                       taskName: String = "myTask"): MyTask {
                                return project.tasks.create&lt;MyTask>(taskName).apply {
                                    // TODO
                                }
                            }
                      }
                    }
                </code></pre>
            </section>
            <section data-auto-animate>
                <h1 data-id="title">Tasks</h1>
                <h3 data-id="subtitle">Companion Object</h3>
                <aside class="notes">
                    set properties and defaults
                </aside>
                <pre data-id="code" class="kotlin"><code data-trim data-noescape data-line-numbers="7-10">
                    abstract class MyTask : DefaultTask() {
                        companion object {
                            @JvmStatic
                            fun create(project: Project,
                                       taskName: String = "myTask"): MyTask {
                                return project.tasks.create&lt;MyTask>(taskName).apply {
                                    outputFile.set(input.map {
                                        project.buildDir.resolve("$it.txt")
                                    })
                                    input.convention("name")
                                }
                            }
                        }
                    }
                </code></pre>
            </section>
            <section data-auto-animate>
                <h1 data-id="title">Tasks</h1>
                <h3 data-id="subtitle">Companion Object</h3>
                <aside class="notes">
                    control up-to-date / caching
                </aside>
                <pre data-id="code" class="kotlin"><code data-trim data-noescape data-line-numbers="7">
                    abstract class MyTask : DefaultTask() {
                        companion object {
                            @JvmStatic
                            fun create(project: Project,
                                       taskName: String = "myTask"): MyTask {
                                return project.tasks.create&lt;MyTask>(taskName).apply {
                                    outputs.upToDateWhen { false }
                                }
                            }
                        }
                    }
                </code></pre>
            </section>
            <section data-auto-animate>
                <h1 data-id="title">Tasks</h1>
                <h3 data-id="subtitle">Companion Object</h3>
                <aside class="notes">
                    bind properties to extension properties
                </aside>
                <pre data-id="code" class="kotlin"><code data-trim data-noescape data-line-numbers="7-9">
                    abstract class MyTask : DefaultTask() {
                        companion object {
                            @JvmStatic
                            fun create(project: Project,
                                       taskName: String = "myTask"): MyTask {
                                return project.tasks.create&lt;MyTask>(taskName).apply {
                                    project.extensions.findByType&lt;MyExtension>()
                                        ?.input.set(it.myTaskOutputName)
                                }
                            }
                        }
                    }
                </code></pre>
            </section>
        </section>
        <section>
            <section data-auto-animate>
                <h1 data-id="title">Extensions</h1>
                <h3>Exposing configuration to buildscripts</h3>
            </section>
            <section data-auto-animate>
                <h1 data-id="title">Extensions</h1>
                <pre class="kotlin"><code data-trim data-noescape>
                    open class MyExtension(objects: ObjectFactory) {
                        companion object {
                            @JvmStatic
                            fun create(project: Project): MyExtension {
                                return project.extensions.create&lt;MyExtension>("my")
                                    .apply { name.convention(project.rootProject.name) }
                            }
                        }

                        val name: Property&lt;String> = objects.property(String::class.java)

                        fun name(newName: String) {
                            name.set(newName)
                        }
                    }
                </code></pre>
            </section>
            <section data-auto-animate>
                <h1 data-id="title">Extensions</h1>
                <h3>Usage</h3>
                <pre class="groovy fragment"><code data-trim data-noescape>
                    my {
                        name("customName")
                    }
                </code></pre>
            </section>
        </section>
        <section>
            <section data-auto-animate>
                <h1>Plugins</h1>
                <h3>Workhorse of the Configuration Phase</h3>
            </section>
            <section data-auto-animate>
                <h1>Plugins</h1>
                <pre class="kotlin"><code data-trim data-noescape>
class MyPlugin : Plugin&lt;Project> {
    override fun apply(project: Project) {
    }
}
                </code></pre>
            </section>
            <section data-auto-animate>
                <h1>Plugins</h1>
                <h3>Apply Tasks & Extensions</h3>
                <pre class="kotlin"><code data-trim data-noescape>
class MyPlugin : Plugin&lt;Project> {
    override fun apply(project: Project) {
        val ext = MyExtension.create(project)
        val task = MyTask.create(project)
    }
}
                </code></pre>
            </section>
            <section data-auto-animate>
                <h1>Plugins</h1>
                <h3>Apply Other Plugins</h3>
                <pre class="kotlin"><code data-trim data-noescape>
class MyPlugin : Plugin&lt;Project> {
    override fun apply(project: Project) {
        project.pluginManager.apply(JavaPlugin::class.java)
    }
}
                </code></pre>
            </section>
            <section data-auto-animate>
                <h1>Plugins</h1>
                <h3>React to Other Plugins</h3>
                <pre class="kotlin"><code data-trim data-noescape>
class MyPlugin : Plugin&lt;Project> {
    override fun apply(project: Project) {
        project.pluginManager.withType(JavaPlugin::class) {
            project.repositories {
                // configure custom repo
            }
            project.withConvention(JavaPluginConvention::class) {
                sourceSets.create("customSourceSet"){
                    // configure custom source set
                }
            }
        }
    }
}
                </code></pre>
            </section>
        </section>
        <section>
            <section><h1>Best Practices</h1></section>
            <section><h2>Avoid afterEvaluate</h2>
                <aside class="notes">
                    exception: when declaring task dependencies on dynamic tasks
                </aside>
                <pre class="kotlin fragment"><code data-trim data-noescape>
class MyPlugin : Plugin&lt;Project> {
  override fun apply(project: Project) {
    val task = MyTask.create(project)
    project.afterEvaluate {
      project.tasks
        .findByName("publishMavenJavaPublicationToMavenRepository")
        .dependsOn(task)
    }
  }
}
                </code></pre>
            </section>
            <section><h2>Project Properties</h2>
                <aside class="notes">
                    Do NOT read extension properties in plugin code. if they are set in buildscript, that will not have been evaluated yet
                </aside>
                <ul>
                    <li class="fragment">Use extension properties when used in task logic</li>
                    <li class="fragment">Do NOT read extension properties in plugin code</li>
                    <li class="fragment">Use project properties when used in plugin logic</li>
                </ul>
            </section>
            <section>
                <h1>Implementation</h1>
                <pre class="kotlin fragment"><code data-trim data-noescape>
class MyPlugin : Plugin&lt;Project> {
    override fun apply(project: Project) {
        if(!project.hasProperty("my.enabled")
            || project.property("my.enabled")){
                    // plugin code
        }
    }
}
                </code></pre>
            </section>
            <section>
                <h2>Usage</h2>
                <div class="fragment">
                    <h3>gradle.properties</h3>
                    <pre class="properties"><code data-trim data-noescape>
                    my.enabled=false
                </code></pre>
                </div>
                <div class="fragment">
                    <h3>Command Line</h3>
                    <pre class="bash"><code data-trim data-noescape>
                    ./gradlew -Pmy.enabled=false
                </code></pre>
                </div>
            </section>
        </section>
        <section>
            <section data-timing="10" data-auto-animate><h1>Testing</h1></section>
            <section data-timing="60" data-auto-animate>
                <h1 data-id="title">Testing</h1>
                <h3 data-id="subtitle">Unit Tests</h3>
                <ul>
                    <li class="fragment">Programmatic access to Project model</li>
                    <li class="fragment">Good for checking configuration</li>
                    <li class="fragment">If you run tasks, run them directly</li>
                    <li class="fragment">Avoid causing dependencies to resolve</li>
                </ul>
            </section>
            <section data-timing="30" data-auto-animate>
                <h1 data-id="title">Testing</h1>
                <h3 data-id="subtitle">Unit Tests</h3>
                <pre class="kotlin"><code data-trim data-noescape>
        val rootProject = ProjectBuilder.builder().build() as ProjectInternal
        val subProject = ProjectBuilder.builder()
                    .withParent(rootProject)
                    .build() as ProjectInternal

        subProject.plugins.apply(JavaPlugin::class.java)
        subProject.plugins.apply(MyPlugin::class.java)

        subProject.evaluate()
        rootProject.evaluate()

        assertThat(subProject.tasks.findByName("myTask")).isNotNull()
        subProject.tasks.findByName("myTask").doWork()
                </code></pre>
            </section>
            <section data-auto-animate>
                <h1 data-id="title">Testing</h1>
                <h3 data-id="subtitle">Integration Tests</h3>
                <ul data-id="body">
                    <li class="fragment">Run a whole gradle build</li>
                    <li class="fragment">works on gradle scripts you write to a temp dir</li>
                    <li class="fragment">Pass in gradle version to use</li>
                    <li class="fragment">parameterize to test multiple gradle verisons</li>
                </ul>
            </section>
            <section data-auto-animate>
                <h1 data-id="title">Testing</h1>
                <h3 data-id="subtitle">Integration Tests</h3>
                <pre data-id="body" class="kotlin"><code data-trim data-noescape>
                rootProjectDir.resolve("build.gradle").apply {
                    createNewFile()
                    writeText("""plugins {
                            id("java")
                            id("com.myorg.myplugin")
                        }""".trimMargin()
                    )
                }
                val buildResult = GradleRunner.create()
                    .withProjectDir(rootProjectDir)
                    .withPluginClasspath()
                    .withArguments("build", "--stacktrace")
                    .withGradleVersion("7.5")
                    .forwardOutput().build()

                assertThat(buildResult.task(":myTask")?.outcome).isEqualTo(SUCCESS)
                </code></pre>
            </section>
        </section>
        <section>
            <section data-auto-animate data-timing="120">
                <h1>Initialization Phase</h1>
                <aside class="notes">
                    init scripts have to be copied to each user's home dir
                    settings plugins must be publicly accessible
                    custom distro can be behind basic auth
                </aside>
                <ul>
                    <li class="fragment">init scripts</li>
                    <li class="fragment">Settings Plugin</li>
                    <li class="fragment">Custom Wrapper Distribution</li>
                </ul>
            </section>
            <section data-auto-animate data-timing="60">
                <h1>Initialization Phase</h1>
                <ul>
                    <li class="fragment">pluginManagement (repo/plugins)</li>
                    <li class="fragment">Gradle Remote Build Cache</li>
                </ul>
            </section>
        </section>
        <section data-timing="10">
            <aside class="notes">
                Now you too can be the weirdo muttering to themselves in the corner
            </aside>
            <img alt="Red Swingline stapler" src="stapler.png" height="500" width="500"/>
        </section>
    </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
        hash: true,
        defaultTiming: 60,
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });


</script>
</body>
</html>
